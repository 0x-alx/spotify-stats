"use client";

import { useState } from "react";
import { Input } from "../input";
import { Button } from "../button";
import { Toaster } from "@/components/ui/sonner";
import { toast } from "sonner";

import { OpenAI } from "openai";
import {
	addTrackToPlaylist,
	createPlaylist,
	getSpotifyProfile,
	getTracks,
	searchSpotifyTrack,
} from "@/hooks/spotifyHooks";

// import data from "../../../data/tracks.json";
import TrackArray from "./TrackArray";

const Frame = ({ userAccount }: { userAccount: any }) => {
	const openai = new OpenAI({
		apiKey: process.env.NEXT_PUBLIC_OPENAI_API_KEY,
		dangerouslyAllowBrowser: true,
	});
	const [tracksInfos, setTracksInfos] = useState([]);
	const [prompt, setPrompt] = useState("");
	const [loading, setLoading] = useState(false);
	const [playlistName, setPlaylistName] = useState("");

	const generatePlaylist = async () => {
		setLoading(true);
		console.log("loading frame:", loading);
		const GPTResponse = await openai.chat.completions.create({
			model: "gpt-3.5-turbo",
			messages: [
				{
					role: "system",
					content:
						"You are a music suggester. You love music, and you love to advice people about it. ",
				},
				{
					role: "user",
					content: `${prompt}. You must generate a public name for this playlist, and provide me with your answer in the following JSON format: {playlistName: 'playlistName', titles: [{title: 'title', artist: 'artist'}]}`,
				},
			],
			response_format: { type: "json_object" },
		});

		const GPTGeneratedTracklist = JSON.parse(
			GPTResponse.choices[0].message.content!
		);

		setPlaylistName(GPTGeneratedTracklist.playlistName);
		let trackListIds: string[] = [];

		const trackSearchPromises = GPTGeneratedTracklist.titles.map(
			async (track: any) => {
				const result = await searchSpotifyTrack({
					accessToken: userAccount?.access_token!,
					query: track.title,
				});
				trackListIds.push(result.tracks.items[0].id);
			}
		);

		await Promise.all(trackSearchPromises);

		const tracksInformations = await getTracks({
			accessToken: userAccount?.access_token!,
			trackIds: trackListIds,
		});
		console.log(tracksInformations.tracks);
		setTracksInfos(tracksInformations.tracks);
		setLoading(false);
	};

	const addPlaylistToSpotify = async () => {
		const spotifyProfile = await getSpotifyProfile({
			accessToken: userAccount?.access_token!,
		});

		const playlist = await createPlaylist({
			accessToken: userAccount?.access_token!,
			userId: spotifyProfile.id,
			name: "SpotifAI - " + playlistName,
		});

		const trackListIds = tracksInfos.map((track: any) => track.uri);

		await addTrackToPlaylist({
			accessToken: userAccount?.access_token!,
			playlistId: playlist.id,
			trackId: trackListIds,
		}).then(
			() => {
				toast("Playlist successfully added to Spotify");
			},
			() => {
				toast("An error occurred while adding the playlist to Spotify");
			}
		);
	};

	function millisToMinutesAndSeconds(millis: number) {
		var minutes = Math.floor(millis / 60000);
		var seconds = Math.round((millis % 60000) / 1000);
		return seconds === 60
			? minutes + 1 + ":00"
			: minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
	}
	return (
		<div className='flew-wrap z-10 flex w-full max-w-[80%] flex-col items-start justify-between gap-8 font-mono text-sm lg:flex'>
			<Toaster />
			<div>
				<h1 className='text-2xl font-bold'>SpotifAI</h1>
				<p className='text-sm'>
					Your personalized playlist, generated by GPT-3.5
				</p>
			</div>
			<div className='flex w-full flex-col gap-4 self-center lg:flex-row'>
				<Input
					type='text'
					placeholder='Search'
					className='w-full'
					onChange={(e) => setPrompt(e.target.value)}
				/>
				<Button onClick={generatePlaylist}>Generate</Button>
			</div>
			{tracksInfos.length > 0 && (
				<Button onClick={addPlaylistToSpotify}>
					Add Playlist to Spotify
				</Button>
			)}

			<div className='flex w-full flex-wrap self-center'>
				<h1 className='text-2xl font-bold'>{playlistName}</h1>
				<TrackArray
					data={tracksInfos}
					isLoading={loading}
				/>
			</div>
		</div>
	);
};

export default Frame;
